# -*- coding: utf-8 -*-
"""Copy of pune_house_price.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YrZcRGZDNLA8PDmPIFi5g-JS7uKi9VdD
"""

import pandas as pd
import numpy as np
data = r"Pune_House_Data.csv"
df = pd.read_csv(data)
df.head()

"""## Data Preprocessing"""

df.shape

df.info()

"""for column in df.columns:
    print(df[column].value_counts())
"""

df.isna().sum()

df.drop(columns=['area_type','availability', 'society', 'balcony'], inplace=True)

df.describe()

df.info()

df['location']=df['location'].fillna('Alandi Road')

df['size']=df['size'].fillna('2 BHK')

df['bath']=df['bath'].fillna(2.69)

df.info()

# handle size column
def extract_numeric_size(value):
    # Split the string and extract the numeric part
    parts = value.split()
    for part in parts:
        if part.isdigit():
            return int(part)
    return None

# Step 3: Apply the function to the 'size' column
df['size'] = df['size'].apply(extract_numeric_size)

df.head()

df.rename(columns={'size': 'BHK'}, inplace=True)

df.head()

df.describe()

df.info()

df.head(10)

print(df['bath'].unique())

print(df['total_sqft'].unique())

def convertrange(x):
    temp = x.split('-')
    if len(temp)==2:
        return (float(temp[0])+float(temp[1]))/2
    try:
        return float(x)
    except:
        return None

df['total_sqft']=df['total_sqft'].apply(convertrange)

df.head()

print(df['total_sqft'].unique())

df.dtypes

df['bath'].unique()

print(df['bath'].isna().sum())

df['bath'] = pd.to_numeric(df['bath'], errors='coerce')

df.dtypes

# price per square feet
df['price_per_sqft'] = (df['price']*100000) / df['total_sqft']

df['price_per_sqft']

df.describe()

print(df['bath'].isna().sum())

med = df['bath'].median()

df['bath']= df['bath'].fillna(med)

df.describe()

print(df['total_sqft'].isna().sum())

medi= df['total_sqft'].median()

df['total_sqft']= df['total_sqft'].fillna(medi)

df['price_per_sqft'] = (df['price']*100000) / df['total_sqft']

df.describe()

df['location'] = df['location'].apply(lambda x: x.strip())
location_count = df['location'].value_counts()

location_count

df.describe()

df['total_sqft'] = pd.to_numeric(df['total_sqft'],errors = 'coerce')
Q1 = df['total_sqft'].quantile(0.25)
Q3 = df['total_sqft'].quantile(0.75)
IQR = Q3 - Q1
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR
lower_bound
upper_bound

# Remove the outliers
df = df[(df['total_sqft'] >= lower_bound) & (df['total_sqft'] <= upper_bound)]

# Print the number of rows before and after removing outliers
print(f"Number of rows before removing outliers: {len(df)}")
print(f"Number of rows after removing outliers: {len(df)}")

df.describe()

# remove outliers from column 'price_per_sqft'
# Calculate Q1 (25th percentile) and Q3 (75th percentile)
Q1 = df['price_per_sqft'].quantile(0.25)
Q3 = df['price_per_sqft'].quantile(0.75)

# Calculate the IQR
IQR = Q3 - Q1

# Define the lower and upper bounds for outliers
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# Remove the outliers
df = df[(df['price_per_sqft'] >= lower_bound) & (df['price_per_sqft'] <= upper_bound)]

df.describe()

import matplotlib.pyplot as plt

# box plot after removing outliers in column 'total_sqft'
plt.figure(figsize=(10, 6))
plt.boxplot(df['total_sqft'], vert=False)
plt.title('Box Plot of total Square Feet (Cleaned)')
plt.xlabel('Total Square Feet')
plt.show()

plt.figure(figsize=(10, 6))
plt.boxplot(df['total_sqft'],vert=False)
plt.title("Box Plot of total Square Feet")
plt.xlabel("Total Square Feet")
plt.show()



df.shape

df

df.drop(columns = ['price_per_sqft'],inplace = True)

# cleaned data
df

df.to_csv('Cleaned_data.csv')

x = df.drop(columns=['price'])
y = df['price']

x

y

"""## import libraries"""

from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression, Lasso, Ridge
from sklearn.preprocessing import OneHotEncoder, StandardScaler
from sklearn.compose import make_column_transformer
from sklearn.pipeline import make_pipeline
from sklearn.metrics import r2_score

X_train, X_test, y_train, y_test = train_test_split(x,y,test_size=0.2,random_state=0)

print (X_train.shape)
print (X_test.shape)

print (y_train.shape)

column_trans = make_column_transformer((OneHotEncoder(sparse_output= False), ['location']), remainder = 'passthrough')

column_trans

scaler = StandardScaler()

"""## apply linear regression"""

lr = LinearRegression()

pipe= make_pipeline(column_trans, scaler, lr)

pipe.fit(X_train, y_train)

y_pred_lr = pipe.predict(X_test)

y_pred_lr

r2_score(y_test, y_pred_lr)

"""## apply Lasso regression"""

lasso = Lasso()

pipe= make_pipeline(column_trans, scaler, lasso)

pipe.fit(X_train, y_train)

y_pred_lasso = pipe.predict(X_test)

r2_score(y_test, y_pred_lasso)

"""## apply ridge regression"""

ridge = Ridge()

pipe= make_pipeline(column_trans, scaler, ridge)

pipe.fit(X_train, y_train)

y_pred_ridge = pipe.predict(X_test)

r2_score(y_test, y_pred_ridge)

import pickle

pickle.dump(pipe, open('Model.pkl', 'wb'))



